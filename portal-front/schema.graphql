directive @auth(requires: [Restriction] = [BYPASS]) repeatable on OBJECT | FIELD_DEFINITION

enum UserOrdering {
  email
}

type Capability implements Node {
  id: ID!
  name: Restriction!
}

type User implements Node {
  id: ID!
  email: String!
  first_name: String
  last_name: String
  organization_id: ID!
  organization: Organization!
  capabilities: [Capability!]!
}

type UserEdge {
  cursor: String!
  node: User
}

type UserConnection {
  edges: [UserEdge!]!
  pageInfo: PageInfo!
}

type UserSubscription {
  add: User
  edit: User
  delete: User
  merge: MergeEvent
}

type Subscription {
  User: UserSubscription
  Service: ServiceSubscription
}

type Query {
  me: User
  user(id: ID!): User
  users(first: Int!, after: ID, orderBy: UserOrdering!, orderMode: OrderingMode!): UserConnection!
  services(first: Int!, after: ID, orderBy: ServiceOrdering!, orderMode: OrderingMode!): ServiceConnection!
  organization(id: ID!): Organization
  organizations(first: Int = 10, after: ID, orderBy: OrganizationOrdering = name, orderMode: OrderingMode = asc): OrganizationConnection!
  node(id: ID!): Node
}

input EditUserInput {
  email: String!
  first_name: String
  last_name: String
  organization_id: String!
}

input AddUserInput {
  email: String!
  password: String!
  organization_id: String!
}

type Mutation {
  mergeTest(from: ID!, target: ID!): ID!
  addUser(input: AddUserInput!): User
  editUser(id: ID!, input: EditUserInput!): User
  deleteUser(id: ID!): User
  login(email: String!, password: String): User
  logout: ID!
  editService(id: ID!, name: String!): Service
  addService(name: String!): Service
  deleteService(id: ID!): Service
  addOrganization(name: String!): Organization
}

enum ServiceOrdering {
  name
}

type Service implements Node {
  id: ID!
  name: String!
  description: String
}

type ServiceEdge {
  cursor: String!
  node: Service!
}

type ServiceConnection {
  edges: [ServiceEdge!]!
  pageInfo: PageInfo!
}

type ServiceSubscription {
  add: Service
  edit: Service
  delete: Service
}

enum OrganizationOrdering {
  name
}

type Organization implements Node {
  id: ID!
  name: String
}

type OrganizationEdge {
  cursor: String!
  node: Organization!
}

type OrganizationConnection {
  edges: [OrganizationEdge!]!
  pageInfo: PageInfo!
}

enum Restriction {
  BYPASS
  ADMIN
  USER
}

interface Node {
  id: ID!
}

enum OrderingMode {
  asc
  desc
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type MergeEvent implements Node {
  id: ID!
  from: ID!
  target: ID!
}