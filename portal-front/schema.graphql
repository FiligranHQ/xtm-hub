directive @auth(requires: [Restriction] = []) repeatable on OBJECT | FIELD_DEFINITION

scalar JSON

scalar Date

scalar Upload

enum MalwareAnalysisOrdering {
  created_at
}

type MalwareAnalysisResult implements Node {
  id: ID!
  result: JSON!
}

type GlimpsCallbackTemporary {
  result: JSON!
}

type MalwareAnalysis implements Node {
  id: ID!
  name: String!
  created_at: Date!
  ended_at: Date
  result: JSON!
  status: String!
  type: String!
}

type MalwareAnalysisEdge {
  cursor: String!
  node: MalwareAnalysis!
}

type MalwareAnalysisConnection {
  totalCount: Int!
  edges: [MalwareAnalysisEdge!]!
  pageInfo: PageInfo!
}

type Query {
  malwareAnalysis(first: Int = 50, after: ID, orderBy: MalwareAnalysisOrdering!, orderMode: OrderingMode!): MalwareAnalysisConnection!
  organization(id: ID!): Organization
  organizations(first: Int = 50, after: ID, orderBy: OrganizationOrdering!, orderMode: OrderingMode!): OrganizationConnection!
  rolePortal(id: ID!): RolePortal
  rolesPortal: [RolePortal!]!
  services(first: Int!, after: ID, orderBy: ServiceOrdering!, orderMode: OrderingMode!): ServiceConnection!
  communities(first: Int!, after: ID, orderBy: ServiceOrdering!, orderMode: OrderingMode!): ServiceConnection!
  settings: Settings!
  subscription(id: ID!): Subscription
  subscriptions(first: Int = 50, after: ID, orderBy: SubscriptionOrdering!, orderMode: OrderingMode!): SubscriptionConnection!
  subscriptionsByOrganization(first: Int = 50, after: ID, orderBy: SubscriptionOrdering!, orderMode: OrderingMode!): SubscriptionConnection!
  userServiceOwned(first: Int!, after: ID, orderBy: UserServiceOrdering!, orderMode: OrderingMode!): UserServiceConnection
  serviceUsers(id: ID!, first: Int!, after: ID, orderBy: UserServiceOrdering!, orderMode: OrderingMode!): UserServiceConnection
  me: User
  user(id: ID!): User
  users(first: Int!, after: ID, orderBy: UserOrdering!, orderMode: OrderingMode!, filter: String): UserConnection!
  node(id: ID!): Node
}

type Mutation {
  malwareAnalysis(string: String, file: Upload): MalwareAnalysis!
  malwareAnalysisResult(id: ID!, status: String!, result: JSON!): GlimpsCallbackTemporary
  addOrganization(name: String!): Organization
  editOrganization(id: ID!, input: EditOrganizationInput!): Organization
  deleteOrganization(id: ID!): Organization
  addServicePrice(input: AddServicePriceInput): ServicePrice
  editService(id: ID!, name: String!): Service
  addService(input: AddServiceInput): Subscription
  addServiceCommunity(input: AddServiceCommunityInput): Service
  acceptCommunity(input: ServiceCommunityAcceptInput): [Subscription]
  deleteService(id: ID!): Service
  addSubscription(service_id: String, organization_id: ID, user_id: ID, billing: Int): Subscription
  editSubscription(id: ID!, input: EditSubscriptionInput!): Subscription
  editServiceCapability(input: EditServiceCapabilityInput): UserService
  addUserService(input: UserServiceInput!): UserService
  deleteUserService(input: UserServiceInput!): UserServiceDeleted
  mergeTest(from: ID!, target: ID!): ID!
  addUser(input: AddUserInput!): User
  editUser(id: ID!, input: EditUserInput!): User
  deleteUser(id: ID!): User
  login(email: String!, password: String): User
  logout: ID!
}

type MalwareAnalysisSubscription {
  add: MalwareAnalysis
  edit: MalwareAnalysis
  delete: MalwareAnalysis
}

type Subscription implements Node {
  MalwareAnalysis: MalwareAnalysisSubscription
  Service: ServiceSubscription
  id: ID!
  organization_id: ID!
  organization: Organization
  service_id: ID!
  service_url: String
  service: Service
  start_date: Date
  end_date: Date
  status: String
  joining: String
  justification: String
  billing: Int
  ActionTracking: TrackingSubscription
  User: UserSubscription
}

enum OrganizationOrdering {
  name
}

type Organization implements Node {
  id: ID!
  name: String!
  domains: [String!]
}

type OrganizationEdge {
  cursor: String!
  node: Organization!
}

type OrganizationConnection {
  totalCount: Int!
  edges: [OrganizationEdge!]!
  pageInfo: PageInfo!
}

input EditOrganizationInput {
  name: String!
}

type RolePortal implements Node {
  id: ID!
  name: String!
}

type RolePortalID implements Node {
  id: ID!
}

type ServiceLink implements Node {
  id: ID!
  service_id: ID
  url: String
  name: String
}

input AddServicePriceInput {
  service_id: ID
  price: Int
  fee_type: String
}

type ServicePrice implements Node {
  id: ID!
  service_id: ID
  fee_type: String
  start_date: Date
  price: Int
}

enum ServiceOrdering {
  name
  description
  provider
  type
}

type Service implements Node {
  id: ID!
  name: String!
  description: String
  provider: String
  type: String
  subscription_service_type: String
  creation_status: String
  subscribed: Boolean
  links: [ServiceLink]
  organization: [Organization]
  subscription: [Subscription]
}

type ServiceEdge {
  cursor: String!
  node: Service!
}

type ServiceConnection {
  totalCount: Int!
  edges: [ServiceEdge!]!
  pageInfo: PageInfo!
}

input AddServiceInput {
  service_name: String
  service_description: String
  fee_type: String
  price: Int
  organization_id: String
  url: String
}

input AddServiceCommunityInput {
  community_name: String
  community_description: String
  justification: String
  price: Int
  fee_type: String
  organizations_id: [String]
  billing_manager: String
}

input ServiceCommunityAcceptInput {
  serviceId: String
  organizationsId: [String]
}

type ServiceSubscription {
  add: Service
  edit: Service
  delete: Service
}

type PlatformProvider {
  name: String!
  type: String!
  provider: String!
}

type Settings {
  platform_providers: [PlatformProvider!]!
}

enum SubscriptionOrdering {
  organization_name
  start_date
  end_date
  status
  service_name
  service_provider
  service_type
  service_description
}

type SubscriptionEdge {
  cursor: String!
  node: Subscription!
}

type SubscriptionConnection {
  totalCount: Int!
  edges: [SubscriptionEdge!]!
  pageInfo: PageInfo!
}

input EditSubscriptionInput {
  status: String
}

type ActionTracking implements Node {
  id: ID!
  contextual_id: String!
  status: String
  created_at: Date!
  ended_at: Date
  message_tracking: [MessageTracking!]!
}

type MessageTracking implements Node {
  id: ID!
  tracking_id: ID
  created_at: Date!
  technical: Boolean
  type: String!
  tracking_info: JSON
}

type TrackingSubscription {
  add: ActionTracking
  edit: ActionTracking
  delete: ActionTracking
}

type ServiceCapability implements Node {
  id: ID!
  service_capability_name: String
  user_service_id: ID!
}

input EditServiceCapabilityInput {
  user_service_id: String
  capabilities: [String]!
}

enum UserServiceOrdering {
  first_name
  last_name
  email
  service_name
  service_provider
  service_type
  service_description
  subscription_status
}

input UserServiceInput {
  email: String!
  capabilities: [String]
  subscriptionId: String!
}

type UserServiceConnection {
  totalCount: Int!
  edges: [UserServiceEdge!]!
  pageInfo: PageInfo!
}

type UserServiceEdge {
  cursor: String!
  node: UserService
}

type UserService implements Node {
  id: ID!
  subscription_id: ID!
  user_id: ID!
  user: User
  subscription: Subscription
  service_capability: [ServiceCapability]
}

type UserServiceDeleted implements Node {
  id: ID!
  subscription_id: ID!
  user_id: ID!
}

enum UserOrdering {
  email
  first_name
  last_name
}

type Capability implements Node {
  id: ID!
  name: Restriction!
}

type User implements Node {
  id: ID!
  email: String!
  first_name: String
  last_name: String
  organization_id: String!
  organization: Organization!
  capabilities: [Capability!]!
  tracking_data: [ActionTracking]
  roles_portal_id: [RolePortalID!]!
}

type UserEdge {
  cursor: String!
  node: User!
}

type UserConnection {
  totalCount: Int!
  edges: [UserEdge!]!
  pageInfo: PageInfo!
}

input EditUserInput {
  email: String!
  first_name: String
  last_name: String
  organization_id: String!
  roles_id: [String]!
}

input AddUserInput {
  email: String!
  password: String!
  organization_id: String!
  first_name: String!
  last_name: String!
  roles_id: [String]!
}

type UserSubscription {
  add: User
  edit: User
  delete: User
  merge: MergeEvent
}

enum Restriction {
  BYPASS
  BCK_MANAGE_SERVICES
  BCK_MANAGE_COMMUNITIES
  FRT_SERVICE_SUBSCRIBER
  FRT_MANAGE_SETTINGS
  FRT_ACCESS_BILLING
  FRT_MANAGE_USER
  FRT_ACCESS_SERVICES
}

interface Node {
  id: ID!
}

enum OrderingMode {
  asc
  desc
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type MergeEvent implements Node {
  id: ID!
  from: ID!
  target: ID!
}